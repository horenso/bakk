\documentclass[final,oneside]{vutinfth}

% Load packages to allow in- and output of non-ASCII characters.
\usepackage{lmodern}        % Use an extension of the original Computer Modern font to minimize the use of bitmapped letters.
\usepackage[T1]{fontenc}    % Determines font encoding of the output. Font packages have to be included before this line.
\usepackage[utf8]{inputenc} % Determines encoding of the input. All input files have to use UTF8 encoding.

% Extended LaTeX functionality is enables by including packages with \usepackage{...}.
\usepackage[inline]{enumitem} % User control over the layout of lists (itemize, enumerate, description).
\usepackage{multirow}   % Allows table elements to span several rows.
\usepackage{booktabs}   % Improves the typesetting of tables.
\usepackage{subcaption} % Allows the use of subfigures and enables their referencing.
\usepackage{minted}
\usepackage[usenames,dvipsnames,table]{xcolor} % Allows the definition and use of colors. This package has to be included before tikz.
\usepackage{nag}       % Issues warnings when best practices in writing LaTeX documents are violated.
\usepackage{todonotes} % Provides tooltip-like todo notes.
\usepackage{hyperref}  % Enables hyperlinking in the electronic document version. This package has to be included second to last.
\usepackage[acronym,toc]{glossaries} % Enables the generation of glossaries and lists of acronyms. This package has to be included last.
\usepackage{listings, listings-rust, listings-json, listings-url} % Code
\usepackage{hyperref}
\lstset{
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true
}

% Define convenience functions here:
\newcommand{\authorname}{Jannis Adamek}
\newcommand{\thesistitle}{Scalability and Event Ordering in PermaplanT's Collaborative Garden Editor}
\newcommand{\thesistitlegerman}{Skalierbarkeit und Ereignisreihenfolge in PermaplanT's kollaborativem Garten-Editor}

\newcommand{\rustsnippet}[1]{%
    \lstinline[
        language=rust,
        breaklines=true,
        breakatwhitespace=true
    ]{#1}%
}
\newcommand{\bashsnippet}[1]{%
    \lstinline[
        language=bash,
        breaklines=true,
        breakatwhitespace=true
    ]{#1}%
}
\newcommand{\pythonsnippet}[1]{%
    \lstinline[
        language=python,
        breaklines=true,
        breakatwhitespace=true
    ]{#1}%
}
\newcommand{\urlsnippet}[1]{%
    \lstinline[
        language=url,
        breaklines=true,
        breakatwhitespace=true
    ]{#1}%
}

\usepackage{pgfplotstable} % For importing CSV files
\usepackage{pgfplots} % For creating plots
\newcommand{\precision}{2}
\newcommand{\perfTableAndGraphFromCsv}[1]{%
    % Load the CSV data into a macro
    \pgfplotstableread[col sep=semicolon]{#1}\loadeddata
    
    % Display the loaded data as a table
    \begin{table}[ht]
    \centering
    \pgfplotstabletypeset[
        string type, % Treat columns as strings if needed
        every head row/.style={before row=\hline, after row=\hline}, % Add horizontal lines
        every last row/.style={after row=\hline}, % Add horizontal line after the last row
        columns={Measuring,Fastest,Slowest,Average,Median}, % Specify the columns to display
        display columns/0/.style={column name=Connected Users},
        display columns/1/.style={
            column name=Fastest,
            fixed,
            dec sep align,
            precision=\precision
        },
        display columns/2/.style={
            column name=Slowest,
            fixed,
            dec sep align,
            precision=\precision
        },
        display columns/3/.style={
            column name=Average,
            fixed,
            dec sep align,
            precision=\precision
        },
        display columns/4/.style={
            column name=Median,
            fixed,
            dec sep align,
            precision=\precision
        }
    ]{\loadeddata} % Use the loaded data
    \end{table}

    % Add a bar graph using the loaded data
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=8cm,
            xlabel={Connected Users},
            ylabel={Time (ms)},
            xtick=data,
            xticklabels from table={\loadeddata}{Measuring},
            legend pos=north west,
            ymajorgrids=true,
            grid style=dashed,
            bar width=3pt, % Set the width of the bars
            ybar,
            legend image code/.code={\draw [#1] (0cm,-0.5em) rectangle (3pt,0.5em); },
        ]

        \addplot table [x expr=\coordindex, y=Fastest]{\loadeddata};
        \addlegendentry{Fastest}

        \addplot table [x expr=\coordindex, y=Slowest]{\loadeddata};
        \addlegendentry{Slowest}

        \addplot table [x expr=\coordindex, y=Average]{\loadeddata};
        \addlegendentry{Average}

        \addplot table [x expr=\coordindex, y=Median]{\loadeddata};
        \addlegendentry{Median}

        \end{axis}
    \end{tikzpicture}
}

% Set PDF document properties
\hypersetup{
    pdfpagelayout   = TwoPageRight,           % How the document is shown in PDF viewers (optional).
    linkbordercolor = {Melon},                % The color of the borders of boxes around hyperlinks (optional).
    pdfauthor       = {\authorname},          % The author's name in the document properties (optional).
    pdftitle        = {\thesistitle},         % The document's title in the document properties (optional).
    pdfsubject      = {TODO: subject},        % The document's subject in the document properties (optional).
    pdfkeywords     = {TODO, list, of, keywords} % The document's keywords in the document properties (optional).
}

\setpnumwidth{2.5em}        % Avoid overfull hboxes in the table of contents (see memoir manual).
\setsecnumdepth{subsection} % Enumerate subsections.

\nonzeroparskip             % Create space between paragraphs (optional).
\setlength{\parindent}{0pt} % Remove paragraph indentation (optional).

\makeindex      % Use an optional index.
\makeglossaries % Use an optional glossary.

% Set persons with 4 arguments:
%  {title before name}{name}{title after name}{gender}
%  where both titles are optional (i.e. can be given as empty brackets {}).
\setauthor{}{\authorname}{}{male}
\setadvisor{Univ.Lektor Dipl.-Ing. Dr.techn.}{Markus Raab}{}{male}

\setregnumber{11809490}
% TODO: set date
\setdate{27}{10}{2024} % Set date with 3 arguments: {day}{month}{year}.
\settitle{\thesistitle}{\thesistitlegerman}
% \setsubtitle{Optional Subtitle of the Thesis}{Optionaler Untertitel der Arbeit} % Sets English and German version of the subtitle (both can be English or German).

\setthesis{bachelor}

% For bachelor and master:
\setcurriculum{Software \& Information Engineering}{Software \& Information Engineering}

\begin{document}

\frontmatter

\addtitlepage{naustrian}
\addtitlepage{english}
\addstatementpage

\begin{acknowledgements*}
I would like to extend my gratitude to the entire PermaplanT team for the fantastic collaboration.
It has been a pleasure working with all of them.
My deepest appreciation goes to my professor, Dr.techn. Markus Raab, for his guidance, advice and patience throughout this process.
A special thanks to MSc Yvonne Markl for her invaluable Permaculture expertise and positive energy.
Lastly, I am thankful to my wonderful partner, Natashia, for her constant encouragement and for helping me stay balanced during this journey.
\end{acknowledgements*}

\begin{abstract}
PermaplanT is a web application for collaborative garden planning featuring a real-time synchronized Map Editor.
A race condition in the broadcasting mechanism can cause clients to receive actions (change events) in the wrong order, leading to inconsistencies between the state displayed to users and the state stored in the database.
Additionally, PermaplanT must scale to support at least 100 concurrent users without performance degradation.
Using Python script, we conducted two tests: a performance test to measure response times with increasing numbers of concurrent connections, and a correctness test to detect cases where broadcasted actions arrived out of order.
The performance test showed that that the system could handle 100 concurrent users, with increasing response times beyond 1000 connections.
The correctness test confirmed that race conditions can indeed lead to event ordering issues.
We present a possible solution to fix the race condition.
\end{abstract}

\selectlanguage{english}

% Acronyms go here
\newacronym{tcp}{TCP}{Transmission Control Protocol}
\newacronym{http}{HTTP}{Hypertext Transfer Protocol}
\newacronym{sse}{SSE}{Server Sent Events}
\newacronym{json}{JSON}{JavaScript Object Notation}
\newacronym{uuid}{UUID}{Universally Unique Identifier}
\newacronym{io}{I/O}{Input Output}

\tableofcontents % Starred version, i.e., \tableofcontents*, removes the self-entry.

% Switch to arabic numbering and start the enumeration of chapters in the table of content.
\mainmatter

\chapter{Introduction}

\section{PermaplanT}

PermaplanT (\url{https://www.permaplant.net}) is an innovative web application that strives to help users plan gardening spaces following the principles of permaculture.
The application uses a web application architecture consisting of a client-side frontend running in the user's web browser and a server-side backend.
The frontend is built using JavaScript and the React framework, while the backend is developed in Rust, backed by the relational database PostgreSQL for data storage.
In addition to the actual application, PermaplanT features a dataset of about 10,000 plant records with information about life cycles, fertility, light and water requirements, and plant relationships.

\section{The Collaborative Map Editor}

The central feature of PermaplanT is its Map Editor, a garden planning tool that allows users to add, remove, and manage garden elements including plants, soil textures, and shading.
To support collaborative garden design, the Map Editor is fully synchronized, so that changes made by one user are reflected in real time on all clients viewing the same map. This is achieved by sending change events, which we will refer to as \emph{actions}.

\section{Research Objective}

In this thesis, we evaluate the performance and correctness of the action broadcasting mechanism within the PermaplanT Map Editor.
One of PermaplanT's non-functional requirements is to support up to 100 concurrent users making changes to the same map without degrading in response times.
We test whether the current implementation of the action broadcasting mechanism adequately achieves this scalability goal.

In terms of correctness, we will test if the sequence of database updates aligns with the sequence of actions that the client receives.
Some actions are order-dependent, e.g. two actions that move the same planting (an instance of a plant on the map) to an absolute position, or an action that moves a planting and another that deletes the same planting.
If actions can arrive out of order, then the state of the client and the state of the database will become inconsistent until the user refreshes the Map Editor page.

In summary, this thesis answers the following questions:
\begin{enumerate}
  \item \textbf{Performance}: How does the duration of \gls{http} requests that modify the state of a map correlate with the number of concurrent users that receive the broadcasted actions on the same map?
  \item \textbf{Correctness}: Is the order of actions that the client receives always in the same order as the respective database writes? 
\end{enumerate}

\chapter{Background}

\section{Map Updates and State Broadcasting}

When a user opens the Map Editor in their web browser, the frontend sends a \texttt{GET} request to the \gls{http} endpoint at the URL \urlsnippet{/api/updates/maps}.
This establishes a unidirectional stream from the server to the client using \gls{sse}.
Through this stream, the client receives map updates in the format \gls{json} referred to as \emph{actions} within PermaplanT.
Each action has a \texttt{type} field, which defines what information it carries.
For example, actions that affect plantings on the map include the following types:
\begin{itemize}
    \item \texttt{CreatePlanting} creates one or more new plantings.
    \item \texttt{MovePlanting} updates the position (x,y) of one or more plantings on the map.
    \item \texttt{TransformPlanting} changes the size of one or more plantings on the map.
\end{itemize}

For each \gls{http} endpoint that modifies the state of the map, the frontend includes a client-generated \gls{uuid} called \texttt{actionId} in the request body.
The backend validates the request, makes the necessary changes to the PostgreSQL database, and then broadcasts the changes via the appropriate action to all open streams that belong to the same map.
\texttt{actionId} is generated by the frontend so that the client can recognize and ignore actions that were caused by its own updates.

\subsection{Map Update Example}

For example, to move one or more plantings, the client makes an \gls{http} \texttt{PATCH} request to \urlsnippet{/api/maps/<map_id>/layers/plants/plantings} with the desired map identifier and the following \gls{json} payload.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=json]
{
  "actionId": "<action_id>",
  "dto": {
    "type": "move",
    "content": [
      {
        "id": "<planting_uuid_1>",
        "x": 10,
        "y": 10
      },
      {
        "id": "<planting_uuid_2>",
        "x": 20,
        "y": 20
      }
    ]
  }
}
\end{lstlisting}
\end{minipage}

This request sets the absolute positions of two plantings.

\section{Race Condition in the Broadcasting Mechanism}
\label{sec:race_condition}

All \gls{http} endpoints in the backend follow the steps of the following simplified illustration in Rust.

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=rust]
async update_plantings(
    map_id: i32,
    update: UpdatePlantingDto,
) -> Result<HttpResponse> {
    // Updates the PostgreSQL database
    let updated = plantings::update(map_id, update).await;
    // Broadcast out the state change to all users
    broadcaster.broadcast(map_id, updated).await;
    // Finishes the HTTP request
    return HttpResponse::Ok().json(updated);
}
\end{lstlisting}
\end{minipage}

In asynchronous Rust, each \rustsnippet{async} function is converted into a state machine that stores the intermediate states from which the function can be suspended and resumed at a later time. 
These suspension entry points are denoted by the expressions \rustsnippet{await}.
This allows asynchronous functions to return back control to the runtime, which may continue with the same function or schedule other tasks concurrently\cite{rustasyncdeepdive2024}.

Asynchronous Rust code is best suited for \gls{io} heavy application.
To achieve effective concurrency, runtime libraries employ a small number of operating system threads, each of which can handle many concurrent tasks\cite{rustasyncbookchapter}. 

In contrast to other programming environments like JavaScript running in the web browser\cite{mdnjavascripteventloop}, Rust doesn't provide any default asynchronous runtime implementation.
PermaplanT uses the runtime library Tokio \cite{tokiocrate} to execute asynchronous Rust code.

Since Rust's asynchronous functions give up control, other tasks may run in between two \rustsnippet{await} statements.
Two update requests can interleave, which can cause actions to be broadcasted to the client in the wrong order.
To illustrate the race condition,
\begin{enumerate}
    \item User 1 makes the \gls{http} request \textit{R1} to move the planting to (100, 100).
    \item User 2 makes the \gls{http} request \textit{R2} to move the same planting to (200, 200).
    \item \rustsnippet{plantings::update().await} finishes in \textit{R1} and stores (100, 100) \
    in the database. The function suspends and the runtime starts executing \textit{R2}.
    \item The runtime fully executes \textit{R2} without interruption.
    (200, 200) is both stored in the database and broadcasted to the client.
    \item Finally, \textit{R1} resumes execution and broadcasts (100, 100).
\end{enumerate}

In this way, the final entry in the database is (200, 200) but the actions are sent in this order: (200, 200) and then (100, 100).
The client incorrectly displays the planting at (100, 100).

\subsection{Critical Section}

As explained by Dubey et al.\cite{artice_race_condition_and_dynamic_data_race_detection}, a race condition occurs when concurrent threads access shared resources without synchronization.
The part of the code that handles the shared resources is called a \textbf{Critical Section}.
In our case, the database update and broadcasting form a critical section together.
Without mutual exclusion, both tasks can occur out of order, leading to inconsistent results.
The article \cite{artice_race_condition_and_dynamic_data_race_detection} further explains that any solution, that deals with securing of critical sections is judged via two mandatory criteria: 
\begin{enumerate}
    \item \textbf{Mutual Exclusion}
    Only one thread should enter the critical section at one given time.
    As discussed, in our case, any request that alters the map should finish the entire request, so that requests never interleave and cause inconsistency.
    What is interesting in our case is that the shared data is not memory on the same computer but the order of network events that cause mutation in the memory of the clients applications.

    It should be noted here that the broadcaster itself is already secured via one Mutex per map.
    \gls{sse} guarantees to preserve the order of messages across the network.
    As specified, RFC 8895 \cite{rfc8895sse} describes the data stream as a reliable ordered connection between the server and the client.
    
    \item \textbf{Progress}
    This means that only the threads that execute the critical section should pay for its synchronization.
    We want to place the synchronization mechanism as narrow as possible, for example by having one mechanism (like a Mutex) per map instead of one global mechanism for the section.
\end{enumerate}

\chapter{Related Work}

Thore Fechner developed a web application called Ehtermap to demonstrate real-time synchronization for collaborative editing of geospatial data on a map\cite{ethermap}.

Ethermap uses continuous synchronization of all changes.
In contrast to PermaplanT's Map Editor, Ethermap displays information about all currently connected users and the area of the map users are currently editing.
To handle conflicts and trace changes, Ethermap provides a continuous history feed of all changes on a map.
Users can inspect revisions and restore previous states.

PermaplanT's could benefit from adding visual indicators to signal that other users are working on the same Garden Map.
A history management tool could help users understand changes and experiment more freely, allowing them to revert changes.

Neogy et al. discusses the challenges of maintaining shared awareness among users while supporting independent exploration within a real-time collaboration application. \cite{collaboration_visualizations} 

To bridge that gap, the article introduces interactive features:
\begin{enumerate}
    \item \textbf{Peeking} Temporarily viewing the state of another user.
    \item \textbf{Tracking} Synchronizing views with the views of another user in real time.
    \item \textbf{Forking} Independent exploration starting from the state of another user.
\end{enumerate}

The concept of forking is interesting because it allows users to diverge from the shared state and experiment with alternative configurations.
In PermaplanT it is not possibly to diverge from the synchronized state of the Garden Map.

Litt et al. present Peritext, a Conflict-Free Replicated Data Type (CRDT) algorithm for collaborative rich text editing \cite{peritext}.

Its focus is to ensure that edits from multiple users (such as changing text, editing the format, deleting characters) merge with the user's intent in mind.
Rather than storing formatting as a tree (like XML), Peritext assigns a unique identifier to each character and stores formatting as spans linked to characters.
Deleted characters still remain in the text as tombstones.

Permaplant's Map Editor could use ideas from CRDTs and Peritext
\begin{enumerate}
    \item \textbf{Commutative Operations} The order of operations in Peritext is order-independent.
    Therefore, there is no need to guarantee the correct order of events.
    \item \textbf{Tombstones} Plants marked as deleted could remain on the map.
\end{enumerate}

\chapter{Methodology}

\section{Motivation}

This chapter explains the two types of tests conducted to answer the research questions.
The motivations for the tests are as following.

\begin{itemize}
    \item \textbf{Performance Test:} The \gls{http} request does not return until the broadcaster concludes, so the latency of each request may increase with the number of \gls{sse} connections.
    We aim to determine how response times scale as more observers receive updates.
    \item \textbf{Correctness Test:} Since there is a race condition in the broadcaster we want to confirm that actions can be broadcasted in the wrong order. 
\end{itemize}

\section{Testing Hardware}

The computers used to perform the tests has the following specification:

\begin{itemize}
  \item Operating System: Linux Mint 22 (Linux Kernel 6.8.0-45-generic)
  \item CPU: Intel i7-5820K (12) @ 3600MHz
  \item RAM: 16 GiB DDR4 @ 2133MHz
  \item Storage: 120 GiB Solid State Drive
\end{itemize}

The tests were conducted against PermaplanT version \texttt{v0.4.3} with the Git hash \texttt{7091b1075}.
All mentioned test scripts have been checked into the Permaplant Git repository under \texttt{benchmarks/sse\_benchmark}.

\section{Performance Test}

To evaluate the performance of the event broadcasting mechanism in the PermaplanT Map Editor, we developed a Bash script \bashsnippet{test_perf.sh}.
It measures how long \gls{http} requests, that update a plantings position, take to resolve with an increasing number of simulated concurrent users viewing the same map.

To simulate multiple users viewing the same map, we developed a Python script \bashsnippet{connect_listener.py}.
The script establishes concurrent connections to the event broadcasting service at the endpoint \urlsnippet{/api/updates}.
The number of connections can be configured through command-line arguments.

The python script \bashsnippet{make_request.py} emulates a user making modifications to the map.
The script begins by creating a planting on the map.
It then sends many \gls{http} \texttt{PATCH} requests in succession that alter the plants position.
The script outputs the slowest, the fastest times, as well as the average and median time of all resqusts.

\bashsnippet{test_perf.sh} tests the return times for the differnet amounts of connected users (10 20 50 100 150 200 500 1000 2000 5000 10000).
For each of these measurements the script follows the following steps:
\begin{enumerate}
    \item Start the PermaplanT backend application (built in release mode).
    \item Sleep 5 seconds to let the backend start up and stop churning.
    \item Connect the required amount of users with \bashsnippet{connect_listeners.py}.
    \item Make 200 requests using \bashsnippet{make_request.py}.
    \item Stop the backend application.
\end{enumerate}

\section{Action Order Test}

The script \bashsnippet{test_order.py} tests whether database writes and actions follow the same order.
We want to confirm that the data race discussed in Section~\ref{sec:race_condition} can lead to a different order of database write and actions.

To record database writes in the planting table, we added a PostgreSQL migration script that can be added to the backend.
This migration adds a table called \texttt{planting\_log}, that keeps a log of all moved plantings, with their old and new x and y coordinates.
A trigger, that executes before each update to the \texttt{plantings}, logs all update events into \texttt{planting\_log}.

We developed a script called \bashsnippet{attack.py} that move a planting via the \gls{http} \texttt{patch} request.
It is similar to \bashsnippet{make_request.py} used in the performance tests, but it sends requests in parallel as fast as possible using Pythons \texttt{threading} library.

\bashsnippet{test_order.py} follows these steps:
\begin{enumerate}
    \item Start the backend in release mode.
    \item Sleep 5 seconds to let the backend start up and stop churning.
    \item We delete all entries in the table \texttt{planting_log}.
    \item Start \bashsnippet{connection_listener.py} with 100 simulated concurrent users.
    This is to make the runtime busy and the race condition more likely.
    \item \bashsnippet{connect_listener.py --record_actions=true 1 1> ./target/actions.txt 2>> ./target/error.log &}
    Start \bashsnippet{connection_listener.py} with on listener using \bashsnippet{--record_actions=true}.
    When supplied with this argument, the script records all actions of type \texttt{"MovePlanting"} to stdout.
    \item Now we read out our log of course sorted by the timestamp.
\end{enumerate}

After the script is run, it produces two files in the same format.
\begin{enumerate}
    \item \bashsnippet{actions.txt}
    \item \bashsnippet{db.txt}
\end{enumerate}

We used the \texttt{diff} program to compare both files line by line.
If we find that the order is not the same we reveal that there is a race condition and events are not sent in the correct order.

It is worth noting that if both files are identical there can still be a race condition, it just means that the database write and the actions happened in the same order, not that they are guaranteed to. 

\chapter{Results}

The results clearly show that the current implementation of the broadcasting system can support 100 concurrent users.

\section{Performance Test}
\subsection{Local tests}

\perfTableAndGraphFromCsv{measurements/977c48a3f_base_perf.csv}
\perfTableAndGraphFromCsv{measurements/fix_race_condition.csv}

\section{Action Order Test}

The test moved the same planting on the same time 20,000 in parallel.
On a local setup the likelihood of events out of order increased when we connected more listeners.
With 400 additional connections (+ a 401st connection that keeps track of the received events) there were 34 action received in the wrong order.

\chapter{Discussion}

\section{Performance Test}

\section{Action Order Test}

While the conditions of the test were intentionally designed to trigger the data race, it is questionable whether the data race would happen under real use.
Nevertheless we were able to prove that actions are not guaranteed to be sent out in the correct order.

\section{Possible solutions to the Action ordering problem}

Message ordering is often a problem in distributed systems.

\subsection{Global Event Ordering}

\printglossary[type=\acronymtype,title=Acronyms]

\backmatter

\bibliographystyle{alpha}
\bibliography{thesis}

\end{document}
