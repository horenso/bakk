@misc{rustasyncdeepdive2024,
    author       = {Sandeep Ahluwalia, Deepa Ahluwalia},
    title        = {Understanding Async Await in Rust: From State Machines to Assembly Code},
    howpublished = {\url{https://www.eventhelix.com/rust/rust-to-assembly-async-await/}},
    note         = {Online, Accessed: 2024-07-30},
    year         = {2024}
}
@misc{tokiocrate,
  author = {Tokio Project Developers},
  title = {Tokio: An asynchronous runtime for the Rust programming language},
  year = {2024},
  howpublished = {\url{https://github.com/tokio-rs/tokio}},
  note = {Version 1.x. Available at: https://crates.io/crates/tokio}
}

@book{rustasyncbookchapter,
  author = {The Rust Project Developers},
  title = {The Rust Asynchronous Programming Book},
  chapter = {Why Async?},
  howpublished = {\url{https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html}},
  note = {Online, Accessed: 2025-01-08},
  year = {2024},
  publisher = {n.d},
}

@misc{mdnjavascripteventloop,
  author       = {Mozilla Contributors},
  title        = {JavaScript event loop},
  year         = {n.d.},
  url          = {https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop},
  note         = {Accessed: 2025-01-08}
}

@article{artice_race_condition_and_dynamic_data_race_detection,
author = {Dubey, Mithilesh and Lowe, Devesh and Galhotra, Bhavna},
year = {2019},
month = {06},
pages = {41-46},
title = {A Study on Race Condition and Dynamic Data Race Detection Techniques},
volume = {7},
journal = {International Journal of Computer Sciences and Engineering},
doi = {10.26438/ijcse/v7i6.4146}
}

@misc{rfc793tcp,
    series =    {Request for Comments},
    number =    793,
    howpublished =  {RFC 793},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC0793},
    url =       {https://www.rfc-editor.org/info/rfc793},
    author =    {},
    title =     {{Transmission Control Protocol}},
    pagetotal = 91,
    year =      1981,
    month =     sep,
    abstract =  {},
}

@misc{rfc8895sse,
    series =    {Request for Comments},
    number =    8895,
    howpublished =  {RFC 8895},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8895},
    url =       {https://www.rfc-editor.org/info/rfc8895},
    author =    {Wendy Roome and Y. Richard Yang},
    title =     {{Application-Layer Traffic Optimization (ALTO) Incremental Updates Using Server-Sent Events (SSE)}},
    pagetotal = 52,
    year =      2020,
    month =     nov,
    abstract =  {The Application-Layer Traffic Optimization (ALTO) protocol (RFC 7285) provides network-related information, called network information resources, to client applications so that clients can make informed decisions in utilizing network resources. This document presents a mechanism to allow an ALTO server to push updates to ALTO clients to achieve two benefits: (1) updates can be incremental, in that if only a small section of an information resource changes, the ALTO server can send just the changes and (2) updates can be immediate, in that the ALTO server can send updates as soon as they are available.},
}

@ARTICLE{ethermap,
  author={Nolte, T. and Nolin, M. and Hansson, H.A.},
  journal={IEEE Transactions on Industrial Informatics}, 
  title={Real-time server-based communication with CAN}, 
  year={2005},
  volume={1},
  number={3},
  pages={192-201},
  keywords={Job shop scheduling;Network servers;Bandwidth;Timing;Real time systems;Communication system control;Associate members;Dynamic scheduling;Communication networks;Runtime;Communication systems;controller area network (CAN);protocols;real time systems;scheduling;server-based;share-driven},
  doi={10.1109/TII.2005.852074}
}

@article{peritext,
author = {Litt, Geoffrey and Lim, Sarah and Kleppmann, Martin and van Hardenberg, Peter},
title = {Peritext: A CRDT for Collaborative Rich Text Editing},
year = {2022},
issue_date = {November 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {CSCW2},
url = {https://doi.org/10.1145/3555644},
doi = {10.1145/3555644},
abstract = {Conflict-Free Replicated Data Types (CRDTs) support decentralized collaborative editing of shared data, enabling peer-to-peer sharing and flexible branching and merging workflows. While there is extensive work on CRDTs for plain text, much less is known about CRDTs for rich text with formatting. No algorithms have been published, and existing open-source implementations do not always preserve user intent.In this paper, we describe a model of intent preservation in rich text editing, developed through a series of concurrent editing scenarios. We then describe Peritext, a CRDT algorithm for rich text that satisfies the criteria of our model. The key idea is to store formatting spans alongside the plaintext character sequence, linked to a stable identifier for the first and last character of each span, and then to derive the final formatted text from these spans in a deterministic way that ensures concurrent operations commute.We have prototyped our algorithm in TypeScript, validated it using randomized property-based testing, and integrated it with an editor UI. We also prove that our algorithm ensures convergence, and demonstrate its causality preservation and intention preservation properties.},
journal = {Proc. ACM Hum.-Comput. Interact.},
month = nov,
articleno = {531},
numpages = {36},
keywords = {rich text, conflict-free replicated data types, collaborative editing, asynchronous collaboration}
}

@INPROCEEDINGS{collaboration_visualizations,
  author={Neogy, Rupayan and Zong, Jonathan and Satyanarayan, Arvind},
  booktitle={2020 IEEE Visualization Conference (VIS)}, 
  title={Representing Real-Time Multi-User Collaboration in Visualizations}, 
  year={2020},
  volume={},
  number={},
  keywords={Visualization;Collaboration;Prototypes;Switches;Tools;Real-time systems;Synchronization;Human-centered computing;Visualization;Visualization systems and tools},
  doi={10.1109/VIS47514.2020.00036}
}
